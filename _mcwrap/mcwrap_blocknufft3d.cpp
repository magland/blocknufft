/*
*
* This file was auto-generated by MCWRAP
* https://github.com/magland/mcwrap
*
* You should not edit this file.
* You might not even want to read it.
* 
*/ 

#include "mex.h"

#include "../blocknufft3d.h"

//====================================================================
//====================================================================
        
int mcwrap_size(const mxArray *X,int j);

void mexFunction(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
{

      //mexPrintf("test A\n");
//   Check the number of inputs/outputs
      if (nlhs==0) nlhs=1;
      if (nrhs!=10)
         mexErrMsgTxt("Incorrect number of inputs"); 
      else if (nlhs>2)
         mexErrMsgTxt ("Too many outputs.");

      // mexPrintf("test A.2\n");
//    Setup the set inputs
        //M
        int input_M=(int)(mcwrap_size(prhs[4-1],1));

      //mexPrintf("test B\n");
//    Setup the inputs
        //N1
        double *p_input_N1=mxGetPr(prhs[1-1]);
        int input_N1=(int)p_input_N1[0];
        //N2
        double *p_input_N2=mxGetPr(prhs[2-1]);
        int input_N2=(int)p_input_N2[0];
        //N3
        double *p_input_N3=mxGetPr(prhs[3-1]);
        int input_N3=(int)p_input_N3[0];
        //xyz
        //Check that we have the correct dimensions!
        {
            int numdims=mxGetNumberOfDimensions(prhs[4-1]);
            if (numdims!=2) {
              mexErrMsgTxt("Incorrect number of dimensions in input: xyz");
            }
            const mwSize *dims2=mxGetDimensions(prhs[4-1]);
            int dims[]={ input_M,3 };
            for (long ii=0; ii<numdims; ii++) {
              if (dims[ii]!=dims2[ii]) {
                mexErrMsgTxt("Incorrect size of input: xyz");
              }
            }
        }
        double *input_xyz=mxGetPr(prhs[4-1]);
        
        //nonuniform_d
        //Check that we have the correct dimensions!
        {
            int numdims=mxGetNumberOfDimensions(prhs[5-1]);
            if (numdims!=2) {
              mexErrMsgTxt("Incorrect number of dimensions in input: nonuniform_d");
            }
            const mwSize *dims2=mxGetDimensions(prhs[5-1]);
            int dims[]={ input_M,1 };
            for (long ii=0; ii<numdims; ii++) {
              if (dims[ii]!=dims2[ii]) {
                mexErrMsgTxt("Incorrect size of input: nonuniform_d");
              }
            }
        }
        double *input_nonuniform_d_re=mxGetPr(prhs[5-1]);
        double *input_nonuniform_d_im=mxGetPi(prhs[5-1]);
        double *input_nonuniform_d=(double *)malloc(sizeof(double)*((input_M)*(1)*2));
        for (long ii=0; ii<(input_M)*(1); ii++) {
            input_nonuniform_d[ii*2]=input_nonuniform_d_re[ii];
            if (input_nonuniform_d_im) {
                input_nonuniform_d[ii*2+1]=input_nonuniform_d_im[ii];
            }
            else {
                input_nonuniform_d[ii*2+1]=0;    
            }
        }
        //eps
        double *p_input_eps=mxGetPr(prhs[6-1]);
        double input_eps=p_input_eps[0];
        //K1
        double *p_input_K1=mxGetPr(prhs[7-1]);
        int input_K1=(int)p_input_K1[0];
        //K2
        double *p_input_K2=mxGetPr(prhs[8-1]);
        int input_K2=(int)p_input_K2[0];
        //K3
        double *p_input_K3=mxGetPr(prhs[9-1]);
        int input_K3=(int)p_input_K3[0];
        //num_threads
        double *p_input_num_threads=mxGetPr(prhs[10-1]);
        int input_num_threads=(int)p_input_num_threads[0];
    
      //mexPrintf("test C\n");
//    Setup the outputs
        //uniform_d
        double *output_uniform_d_re;
        double *output_uniform_d_im;
        double *output_uniform_d;
        if (1<=nlhs) {
        if ((3<1)||(3>20)) {
          mexErrMsgTxt("Bad number of dimensions for my taste: 3"); 
        }
        {
            int dims2[]={ input_N1,input_N2,input_N3 };
            for (long ii=0; ii<3; ii++) {
                if ((dims2[ii]<1)||(dims2[ii]>10000000000.0)) {
                  mexErrMsgTxt ("Bad array size for my taste: input_N1,input_N2,input_N3"); 
                }
            }
        }
        
            mwSize dims[]={ input_N1,input_N2,input_N3 };
            plhs[1-1]=mxCreateNumericArray(3,dims,mxDOUBLE_CLASS,mxCOMPLEX);
            output_uniform_d_re=mxGetPr(plhs[1-1]);
            output_uniform_d_im=mxGetPi(plhs[1-1]);
        }
        output_uniform_d=(double *)malloc(sizeof(double)*((input_N1)*(input_N2)*(input_N3))*2);
        //spread
        double *output_spread_re;
        double *output_spread_im;
        double *output_spread;
        if (2<=nlhs) {
        if ((3<1)||(3>20)) {
          mexErrMsgTxt("Bad number of dimensions for my taste: 3"); 
        }
        {
            int dims2[]={ input_N1 * 2,input_N2 * 2,input_N3 * 2 };
            for (long ii=0; ii<3; ii++) {
                if ((dims2[ii]<1)||(dims2[ii]>10000000000.0)) {
                  mexErrMsgTxt ("Bad array size for my taste: input_N1 * 2,input_N2 * 2,input_N3 * 2"); 
                }
            }
        }
        
            mwSize dims[]={ input_N1 * 2,input_N2 * 2,input_N3 * 2 };
            plhs[2-1]=mxCreateNumericArray(3,dims,mxDOUBLE_CLASS,mxCOMPLEX);
            output_spread_re=mxGetPr(plhs[2-1]);
            output_spread_im=mxGetPi(plhs[2-1]);
        }
        output_spread=(double *)malloc(sizeof(double)*((input_N1 * 2)*(input_N2 * 2)*(input_N3 * 2))*2);

    
      //mexPrintf("test D\n");
//    Run the subroutine
        blocknufft3d(
        input_N1,
        input_N2,
        input_N3,
        input_M,
        output_uniform_d,
        output_spread,
        input_xyz,
        input_nonuniform_d,
        input_eps,
        input_K1,
        input_K2,
        input_K3,
        input_num_threads

        );
   
      //mexPrintf("test E\n");
//    Free the inputs
        //xyz
        //nonuniform_d
        free(input_nonuniform_d);

      //mexPrintf("test F\n");
//    Set the outputs
        //uniform_d
        if (1<=nlhs) {
            for (long ii=0; ii<(input_N1)*(input_N2)*(input_N3); ii++) {
                output_uniform_d_re[ii]=output_uniform_d[ii*2];
                output_uniform_d_im[ii]=output_uniform_d[ii*2+1];
            }
        }
        free(output_uniform_d);
        //spread
        if (2<=nlhs) {
            for (long ii=0; ii<(input_N1 * 2)*(input_N2 * 2)*(input_N3 * 2); ii++) {
                output_spread_re[ii]=output_spread[ii*2];
                output_spread_im[ii]=output_spread[ii*2+1];
            }
        }
        free(output_spread);

      //mexPrintf("test G\n");

/**** We are done *******/
}

int mcwrap_size(const mxArray *X,int j) {
    mwSize numdims=mxGetNumberOfDimensions(X);
    if ((j<1)||(j>numdims)) return 1;
    const mwSize *dims2=mxGetDimensions(X);
    return dims2[j-1];
}

        //$pname$
//CC Scalar output not yet supported!
